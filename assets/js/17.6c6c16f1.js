(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{394:function(n,e,t){"use strict";t.r(e);var a=t(42),o=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"panorama_container"}},[e("script",{attrs:{src:"/three.js"}}),this._v(" "),e("canvas",{attrs:{id:"panorama_canvas"}}),this._v(" "),e("style",[this._v("\n    body {\n        position: relative;\n        margin: 0;\n        padding: 0;\n        overflow: hidden;\n        background-color: #ff00ff;\n    }\n    #panorama_canvas {\n        background-color: #ff00ff;\n    }\n    #panorama_container {\n        height: 100vh;\n        width: 100vw;\n    }\n")]),this._v(" "),e("script",[this._v("\n    \n    function ready(fn) {\n        if (document.readyState != 'loading') {\n            fn();\n        } else {\n            document.addEventListener('DOMContentLoaded', fn);\n        }\n    }\n\n    let el,\n        scene,\n        camera,\n        loader,\n        renderer = new THREE.WebGLRenderer()\n\n        let startX = 0,\n        lastX = 0,\n        startY = 0,\n        lastY = 0,\n        lon = 0,\n        lat = 0,\n        factor = 0.1\n\n    const opt = {\n        fov: 90,\n        aspectRatio: 1,\n        width: 800,\n        height: 600,\n        near: 0.01,\n        far: 10000,\n        imageUrl: './public/assets/img/quanjing.jpg'\n    }\n\n    function resizeView() {\n        el.width = opt.width = window.innerWidth\n        el.height = opt.height = window.innerHeight\n        renderer.setSize(el.width, el.height)\n        camera.aspect = opt.aspectRatio = el.width / el.height\n        camera.updateProjectionMatrix()\n        console.log('window resized')\n    }\n\n    function init() {\n        el = document.getElementById('panorama_canvas')\n\n        scene = new THREE.Scene();\n        scene.background = new THREE.Color(0xff00ff)\n\n        camera = new THREE.PerspectiveCamera(\n            opt.fov,\n            opt.aspectRatio,\n            opt.near,\n            opt.far,\n            opt.radius\n        );\n\n        loader = new THREE.TextureLoader();\n\n        renderer = new THREE.WebGLRenderer({\n            canvas: el\n        })\n        renderer.setPixelRatio(window.devicePixelRatio)\n\n        window.addEventListener('resize', resizeView)\n    }\n\n    function main() {\n        init()\n        resizeView()\n\n        const geometry = new THREE.SphereBufferGeometry(opt.radius, 64, 64)\n        geometry.scale(2, 2, 2)\n\n        window.geometry = geometry\n\n        const material = new THREE.MeshBasicMaterial({\n            side: THREE.DoubleSide\n        })\n\n        loader.load(opt.imageUrl, texture => {\n            material.map = texture\n            console.log('texture loaded')\n        })\n\n        const mesh = new THREE.Mesh(geometry, material)\n\n        scene.add(mesh)\n\n        window.mesh = mesh\n        setInterval(render, 16)\n\n        /*\n        window.addEventListener('touchstart', start)\n        window.addEventListener('touchmove', move)\n\n        function start(event) {\n            const e = event.changedTouches[0]\n            startX = e.clientX\n            lastX = e.clientX\n            startY = e.clientY\n            lastY = e.clientY\n            console.log('a')\n        }\n\n        function move(event) {\n            const e = event.changedTouches[0];\n            if (event.changedTouches.length === 1) {\n                lon += (e.clientX - lastX) * factor\n                lat += (e.clientY - lastY) * factor\n                lastX = e.clientX\n                lastY = e.clientY\n            }\n        }\n        */\n\n        window.addEventListener('mousedown', start)\n        window.addEventListener('mouseup', end)\n\n        function start(e) {\n            startX = e.clientX\n            lastX = e.clientX\n            startY = e.clientY\n            lastY = e.clientY\n            window.addEventListener('mousemove', move)\n        }\n\n        function move(e) {\n            lon += (e.clientX - lastX) * factor\n            lat += (e.clientY - lastY) * factor\n            lastX = e.clientX\n            lastY = e.clientY\n        }\n\n        function end(e) {\n            window.removeEventListener('mousemove', move)\n        }\n    }\n\n    function latlonToXyz (lat, lon) {\n        const cosLat = Math.cos(lat * Math.PI / 180.0)\n        const sinLat = Math.sin(lat * Math.PI / 180.0)\n        const cosLon = Math.cos(lon * Math.PI / 180.0)\n        const sinLon = Math.sin(lon * Math.PI / 180.0)\n        const rad = 1\n        return [\n            rad * cosLat * sinLon,\n            rad * sinLat,\n            rad * cosLat * cosLon,\n        ]\n    }\n\n    function render() {\n        renderer.render(scene, camera)\n    \n        camera.lookAt(...latlonToXyz(lat, lon))\n    }\n\n    var timer = setInterval(function () {\n        if (window.THREE !== undefined) {\n            ready(main)\n            clearInterval(timer)\n        }\n    }, 100)\n")])])}],!1,null,null,null);e.default=o.exports}}]);